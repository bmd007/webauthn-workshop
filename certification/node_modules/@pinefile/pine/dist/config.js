"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.configure = exports.getConfig = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const dotenv_1 = __importDefault(require("dotenv"));
const utils_1 = require("@pinefile/utils");
const logger_1 = require("./logger");
let config = {
    dotenv: [],
    env: {},
    logLevel: 'info',
    options: {},
    root: '',
    require: [],
    task: '',
};
const isError = (error) => error instanceof Error;
const loadDotenv = (config) => {
    if (!Array.isArray(config.dotenv)) {
        return;
    }
    if (!config.root && config.dotenv.length) {
        throw new Error('Config root cannot be empty when loading dotenv files');
    }
    config.dotenv.forEach((file) => {
        try {
            const dotEnvPath = path_1.default.join(config.root, file);
            const stats = fs_1.default.statSync(dotEnvPath);
            // make sure to only attempt to read files
            if (!stats.isFile()) {
                return;
            }
            const result = dotenv_1.default.config({
                path: dotEnvPath,
            });
            if (result.error) {
                throw result.error;
            }
        }
        catch (err) {
            if (isError(err) && err.code !== 'ENOENT') {
                throw err;
            }
        }
    });
    config.dotenv = [];
};
const loadModules = (config) => {
    if (!Array.isArray(config.require)) {
        return;
    }
    config.require = config.require.filter((file) => {
        // eslint-disable-next-line
        require(file);
        return false;
    });
};
const setEnvironment = (config) => {
    if (!(0, utils_1.isObject)(config.env)) {
        return;
    }
    for (const key in config.env) {
        // use the same conditional to set env var as dotenv does
        if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
            process.env[key.toUpperCase()] = config.env[key];
        }
    }
};
const getConfig = () => config;
exports.getConfig = getConfig;
/**
 * Pine can be configured via the configure function, which accepts:
 *
 * > A plain JavaScript object, this will be merged into the existing configuration.
 *
 *   configure({
 *     dotenv: ['my.env'],
 *   })
 *
 * > With a function will be given the existing configuration and the task name as a optional argument.
 * > The function should return a plain JavaScript object which will be merged into the existing configuration.
 *
 *   configure((config) => ({
 *     dotenv: ['my.env'],
 *   }))
 */
const configure = (newConfig) => {
    if (typeof newConfig === 'function') {
        newConfig = newConfig(config);
    }
    config = {
        ...config,
        ...((0, utils_1.isObject)(newConfig) ? newConfig : {}),
    };
    loadDotenv(config);
    loadModules(config);
    setEnvironment(config);
    (0, logger_1.setLogger)(config === null || config === void 0 ? void 0 : config.logger);
    return config;
};
exports.configure = configure;
