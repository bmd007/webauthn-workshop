"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runTask = exports.resolveTask = exports.validTaskValue = void 0;
const pify_1 = __importDefault(require("pify"));
const utils_1 = require("@pinefile/utils");
const color_1 = require("./color");
const config_1 = require("./config");
const runner_1 = require("./runner");
const logger_1 = require("./logger");
/**
 * Determine if input value is a valid task value.
 *
 * @param  {object} val
 *
 * @returns {boolean}
 */
const validTaskValue = (val) => {
    return (typeof val === 'function' ||
        ((0, utils_1.isObject)(val) &&
            !!Object.keys(val).length &&
            (typeof val._ === 'undefined' || typeof val._ === 'function')));
};
exports.validTaskValue = validTaskValue;
/**
 * Bind `this` for task functions to parent object.
 *
 * @param {object} obj
 * @param {function} fn
 *
 * @returns {object|boolean}
 */
const bindTask = (obj, task) => {
    if (!(0, exports.validTaskValue)(task)) {
        return false;
    }
    if (!(0, utils_1.isObject)(task) || !task._) {
        return { ...task, default: bindTask(task, task.default) };
    }
    return {
        ...task,
        _: task._.bind(new Proxy(obj, {
            get(target, handler) {
                if ((0, utils_1.isObject)(target[handler]) &&
                    typeof target[handler]._ === 'function') {
                    return target[handler]._;
                }
            },
        })),
    };
};
/**
 * Resolve task function by name.
 *
 * @param {object} obj
 * @param {string} key
 * @param {string} sep
 *
 * @returns {function|object|boolean}
 */
const resolveTask = (obj, key, sep = ':') => {
    if (!key) {
        return false;
    }
    const properties = (Array.isArray(key) ? key : key.split(sep));
    const task = properties.reduce((prev, cur) => (bindTask(prev, prev[cur]) || {}), obj);
    if (!(0, exports.validTaskValue)(task)) {
        return false;
    }
    if ((0, utils_1.isObject)(task) && task._) {
        return task._;
    }
    if ((0, utils_1.isObject)(task.default)) {
        task.default = task.default._;
    }
    return task;
};
exports.resolveTask = resolveTask;
/**
 * Get task function name with prefix.
 *
 * @param {string} name
 * @param {string} prefix
 * @param {string} sep
 *
 * @returns {string}
 */
const getFnName = (name, prefix = '', sep = ':') => {
    const names = name.split(sep);
    const lastName = names.pop();
    return names.concat(`${prefix}${lastName}`).join(sep);
};
const doneify = (fn, ...args) => async (done) => {
    try {
        await (0, pify_1.default)(fn, { excludeMain: true })(args);
        done();
    }
    catch (err) {
        done(err);
    }
};
/**
 * Execute task in pinefile object.
 *
 * @param {object} pinefile
 * @param {string} name
 * @param {array}  args
 *
 * @returns {Promise}
 */
const execute = async (pinefile, name, args) => {
    const config = (0, config_1.getConfig)();
    let fn = (0, exports.resolveTask)(pinefile, name);
    let fnName = name;
    let fnExists = false;
    // eslint-disable-next-line prefer-const
    let { runner, options } = (0, runner_1.getRunner)(config);
    if (typeof runner === 'function') {
        fn = runner;
        fnExists = true;
    }
    else if ((0, utils_1.isObject)(runner) && typeof runner.default === 'function') {
        fn = runner.default;
        fnExists =
            typeof runner.taskExists === 'function'
                ? runner.taskExists(pinefile, name, args, options)
                : typeof fn === 'function';
    }
    else if (typeof fn === 'function') {
        fnExists = true;
    }
    // use default function in objects.
    if ((0, utils_1.isObject)(fn) && fn.default) {
        fn = fn.default;
        fnName = name !== 'default' ? `${name}:default` : 'default';
        fnExists = typeof fn === 'function';
    }
    // fail if no task function can be found
    if (!fnExists) {
        (0, logger_1.internalLog)().error(`Task ${color_1.color.cyan(`'${name}'`)} not found`);
        return;
    }
    switch (fn.length) {
        case 4:
            // runner function with options
            if ((0, utils_1.isObject)(options) && Object.keys(options).length) {
                runner = fn(pinefile, name, args, options);
            }
            else {
                runner = fn(pinefile, name, args);
            }
            break;
        case 3:
            // 3: plugin or runner function.
            runner = fn(pinefile, name, args);
            break;
        default:
            // 1: task function.
            runner = async (done) => {
                try {
                    const fn2 = (0, pify_1.default)(fn, { excludeMain: true });
                    const fn2Type = typeof fn2;
                    if (fn2Type === 'function') {
                        await fn2(args);
                        done();
                    }
                    else {
                        throw new Error(`Expected task function to be a function, got ${fn2 === null ? 'null' : fn2Type}`);
                    }
                }
                catch (err) {
                    done(err);
                }
            };
            break;
    }
    // execute pre* function.
    const preName = getFnName(fnName, 'pre');
    const preFunc = (0, exports.resolveTask)(pinefile, preName);
    if (preFunc) {
        await execute(pinefile, preName, args);
    }
    const startTime = Date.now();
    (0, logger_1.internalLog)().info(`Starting ${color_1.color.cyan(`'${name}'`)}`);
    // await for runner if Promise
    if (runner instanceof Promise) {
        runner = await runner;
    }
    // create a empty runner and throw a error if not a function.
    if (typeof runner !== 'function') {
        const beforeType = runner === null ? 'null' : typeof runner;
        runner = () => {
            throw new Error(`Expected return value of runner function to be a function, got ${beforeType}`);
        };
    }
    // wrap runner with no arguments
    // with an callback function with
    // done function as a argument.
    if (!runner.length) {
        runner = doneify(runner);
    }
    return await runner(async (err) => {
        if (err)
            (0, logger_1.internalLog)().error(err);
        const time = Date.now() - startTime;
        (0, logger_1.internalLog)().info(`Finished ${color_1.color.cyan(`'${name}'`)} after ${color_1.color.magenta((0, logger_1.timeInSecs)(time))}`);
        // execute post* function.
        const postName = getFnName(fnName, 'post');
        const postFunc = (0, exports.resolveTask)(pinefile, postName);
        if (postFunc) {
            await execute(pinefile, postName, args);
        }
    });
};
/**
 * Run task in pinefile.
 *
 * @param {object} pinefile
 * @param {string} name
 * @param {object} args
 *
 * @returns {Promise}
 */
const runTask = async (pinefile, name, args = {}) => {
    return await execute(pinefile, name, args);
};
exports.runTask = runTask;
