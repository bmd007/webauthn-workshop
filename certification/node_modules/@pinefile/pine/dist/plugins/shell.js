"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.run = exports.shell = exports.shouldForceColor = void 0;
const stream_1 = __importDefault(require("stream"));
const execa_1 = __importDefault(require("execa"));
const toError = (obj) => {
    const err = obj instanceof Error ? obj : new Error(obj);
    if (obj.shortMessage !== undefined) {
        obj.message = obj.shortMessage;
        delete obj.shortMessage;
    }
    return err;
};
const shouldForceColor = (env = {}) => {
    if (!Object.keys(env).length) {
        env = process.env;
    }
    if (!env.FORCE_COLOR) {
        return false;
    }
    if (env.FORCE_COLOR === 'true') {
        return true;
    }
    if (env.FORCE_COLOR === 'false') {
        return false;
    }
    return !!Math.min(parseInt(env.FORCE_COLOR, 10), 3);
};
exports.shouldForceColor = shouldForceColor;
/**
 * Run shell command.
 *
 * @param {string} cmd
 * @param {object} opts
 *
 * @returns {Promise}
 */
const shell = (cmd, opts = {}) => {
    const s = (cmd instanceof Array ? cmd.join(' ') : cmd).split(/\s/);
    return new Promise((resolve, reject) => {
        var _a, _b;
        const sp = (0, execa_1.default)(s[0], s.slice(1), {
            shell: true,
            ...opts,
            env: {
                // @ts-ignore
                FORCE_COLOR: (0, exports.shouldForceColor)(),
                ...opts === null || opts === void 0 ? void 0 : opts.env,
            },
        });
        if ((opts === null || opts === void 0 ? void 0 : opts.stdout) && opts.stdout instanceof stream_1.default.Stream) {
            (_a = sp === null || sp === void 0 ? void 0 : sp.stdout) === null || _a === void 0 ? void 0 : _a.pipe(opts.stdout);
            (_b = sp === null || sp === void 0 ? void 0 : sp.stderr) === null || _b === void 0 ? void 0 : _b.pipe((opts.stderr || opts.stdout));
        }
        else {
            sp.then((res) => resolve(res.stdout)).catch((err) => reject(toError(err)));
        }
        sp.on('close', (code) => {
            if (code !== 0) {
                process.exitCode = code;
            }
            if (opts === null || opts === void 0 ? void 0 : opts.stdout) {
                resolve(null);
            }
        });
    });
};
exports.shell = shell;
/**
 * Run shell command.
 *
 * @param {string} cmd
 * @param {object} opts
 *
 * @returns {Promise}
 */
const run = (cmd, opts = {}) => (0, exports.shell)(cmd, {
    ...opts,
    stdin: 'inherit',
    stdout: 'inherit',
    stderr: 'inherit',
});
exports.run = run;
